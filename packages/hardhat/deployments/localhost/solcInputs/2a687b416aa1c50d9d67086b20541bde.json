{
  "language": "Solidity",
  "sources": {
    "contracts/ERC5564Announcer.sol": {
      "content": "// SPDX-License-Identifier: CC0-1.0\npragma solidity 0.8.23;\n\n/// @notice `ERC5564Announcer` contract to emit an `Announcement` event to broadcast information\n/// about a transaction involving a stealth address. See\n/// [ERC-5564](https://eips.ethereum.org/EIPS/eip-5564) to learn more.\ncontract ERC5564Announcer {\n  /// @notice Emitted when something is sent to a stealth address.\n  /// @param schemeId Identifier corresponding to the applied stealth address scheme, e.g. 1 for\n  /// secp256k1, as specified in ERC-5564.\n  /// @param stealthAddress The computed stealth address for the recipient.\n  /// @param caller The caller of the `announce` function that emitted this event.\n  /// @param ephemeralPubKey Ephemeral public key used by the sender to derive the `stealthAddress`.\n  /// @param metadata Arbitrary data to emit with the event. The first byte MUST be the view tag.\n  /// @dev The remaining metadata can be used by the senders however they like. See\n  /// [ERC-5564](https://eips.ethereum.org/EIPS/eip-5564) for recommendations on how to structure\n  /// this metadata.\n  event Announcement(\n    uint256 indexed schemeId,\n    address indexed stealthAddress,\n    address indexed caller,\n    bytes ephemeralPubKey,\n    bytes metadata\n  );\n\n  /// @notice Called by integrators to emit an `Announcement` event.\n  /// @param schemeId Identifier corresponding to the applied stealth address scheme, e.g. 1 for\n  /// secp256k1, as specified in ERC-5564.\n  /// @param stealthAddress The computed stealth address for the recipient.\n  /// @param ephemeralPubKey Ephemeral public key used by the sender.\n  /// @param metadata Arbitrary data to emit with the event. The first byte MUST be the view tag.\n  /// @dev The remaining metadata can be used by the senders however they like. See\n  /// [ERC-5564](https://eips.ethereum.org/EIPS/eip-5564) for recommendations on how to structure\n  /// this metadata.\n  function announce(\n    uint256 schemeId,\n    address stealthAddress,\n    bytes memory ephemeralPubKey,\n    bytes memory metadata\n  ) external {\n    emit Announcement(schemeId, stealthAddress, msg.sender, ephemeralPubKey, metadata);\n  }\n}\n"
    },
    "contracts/ERC6538Registry.sol": {
      "content": "// SPDX-License-Identifier: CC0-1.0\npragma solidity 0.8.23;\n\n/// @notice `ERC6538Registry` contract to map accounts to their stealth meta-address. See\n/// [ERC-6538](https://eips.ethereum.org/EIPS/eip-6538) to learn more.\ncontract ERC6538Registry {\n  /// @notice Emitted when an invalid signature is provided to `registerKeysOnBehalf`.\n  error ERC6538Registry__InvalidSignature();\n\n  /// @notice Next nonce expected from `user` to use when signing for `registerKeysOnBehalf`.\n  /// @dev `registrant` may be a standard 160-bit address or any other identifier.\n  /// @dev `schemeId` is an integer identifier for the stealth address scheme.\n  mapping(address registrant => mapping(uint256 schemeId => bytes)) public stealthMetaAddressOf;\n\n  /// @notice A nonce used to ensure a signature can only be used once.\n  /// @dev `registrant` is the user address.\n  /// @dev `nonce` will be incremented after each valid `registerKeysOnBehalf` call.\n  mapping(address registrant => uint256) public nonceOf;\n\n  /// @notice The EIP-712 type hash used in `registerKeysOnBehalf`.\n  bytes32 public constant ERC6538REGISTRY_ENTRY_TYPE_HASH =\n    keccak256(\"Erc6538RegistryEntry(uint256 schemeId,bytes stealthMetaAddress,uint256 nonce)\");\n\n  /// @notice The chain ID where this contract is initially deployed.\n  uint256 internal immutable INITIAL_CHAIN_ID;\n\n  /// @notice The domain separator used in this contract.\n  bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n  /// @notice Emitted when a registrant updates their stealth meta-address.\n  /// @param registrant The account that registered the stealth meta-address.\n  /// @param schemeId Identifier corresponding to the applied stealth address scheme, e.g. 1 for\n  /// secp256k1, as specified in ERC-5564.\n  /// @param stealthMetaAddress The stealth meta-address.\n  /// [ERC-5564](https://eips.ethereum.org/EIPS/eip-5564) bases the format for stealth\n  /// meta-addresses on [ERC-3770](https://eips.ethereum.org/EIPS/eip-3770) and specifies them as:\n  ///   st:<shortName>:0x<spendingPubKey>:<viewingPubKey>\n  /// The chain (`shortName`) is implicit based on the chain the `ERC6538Registry` is deployed on,\n  /// therefore this `stealthMetaAddress` is just the compressed `spendingPubKey` and\n  /// `viewingPubKey` concatenated.\n  event StealthMetaAddressSet(\n    address indexed registrant, uint256 indexed schemeId, bytes stealthMetaAddress\n  );\n\n  /// @notice Emitted when a registrant increments their nonce.\n  /// @param registrant The account that incremented the nonce.\n  /// @param newNonce The new nonce value.\n  event NonceIncremented(address indexed registrant, uint256 newNonce);\n\n  constructor() {\n    INITIAL_CHAIN_ID = block.chainid;\n    INITIAL_DOMAIN_SEPARATOR = _computeDomainSeparator();\n  }\n\n  /// @notice Sets the caller's stealth meta-address for the given scheme ID.\n  /// @param schemeId Identifier corresponding to the applied stealth address scheme, e.g. 1 for\n  /// secp256k1, as specified in ERC-5564.\n  /// @param stealthMetaAddress The stealth meta-address to register.\n  function registerKeys(uint256 schemeId, bytes calldata stealthMetaAddress) external {\n    stealthMetaAddressOf[msg.sender][schemeId] = stealthMetaAddress;\n    emit StealthMetaAddressSet(msg.sender, schemeId, stealthMetaAddress);\n  }\n\n  /// @notice Sets the `registrant`'s stealth meta-address for the given scheme ID.\n  /// @param registrant Address of the registrant.\n  /// @param schemeId Identifier corresponding to the applied stealth address scheme, e.g. 1 for\n  /// secp256k1, as specified in ERC-5564.\n  /// @param signature A signature from the `registrant` authorizing the registration.\n  /// @param stealthMetaAddress The stealth meta-address to register.\n  /// @dev Supports both EOA signatures and EIP-1271 signatures.\n  /// @dev Reverts if the signature is invalid.\n  function registerKeysOnBehalf(\n    address registrant,\n    uint256 schemeId,\n    bytes memory signature,\n    bytes calldata stealthMetaAddress\n  ) external {\n    bytes32 dataHash;\n    address recoveredAddress;\n\n    unchecked {\n      dataHash = keccak256(\n        abi.encodePacked(\n          \"\\x19\\x01\",\n          DOMAIN_SEPARATOR(),\n          keccak256(\n            abi.encode(\n              ERC6538REGISTRY_ENTRY_TYPE_HASH,\n              schemeId,\n              keccak256(stealthMetaAddress),\n              nonceOf[registrant]++\n            )\n          )\n        )\n      );\n    }\n\n    if (signature.length == 65) {\n      bytes32 r;\n      bytes32 s;\n      uint8 v;\n      assembly (\"memory-safe\") {\n        r := mload(add(signature, 0x20))\n        s := mload(add(signature, 0x40))\n        v := byte(0, mload(add(signature, 0x60)))\n      }\n      recoveredAddress = ecrecover(dataHash, v, r, s);\n    }\n\n    if (\n      (\n        (recoveredAddress == address(0) || recoveredAddress != registrant)\n          && (\n            IERC1271(registrant).isValidSignature(dataHash, signature)\n              != IERC1271.isValidSignature.selector\n          )\n      )\n    ) revert ERC6538Registry__InvalidSignature();\n\n    stealthMetaAddressOf[registrant][schemeId] = stealthMetaAddress;\n    emit StealthMetaAddressSet(registrant, schemeId, stealthMetaAddress);\n  }\n\n  /// @notice Increments the nonce of the sender to invalidate existing signatures.\n  function incrementNonce() external {\n    unchecked {\n      nonceOf[msg.sender]++;\n    }\n    emit NonceIncremented(msg.sender, nonceOf[msg.sender]);\n  }\n\n  /// @notice Returns the domain separator used in this contract.\n  /// @dev The domain separator is re-computed if there's a chain fork.\n  function DOMAIN_SEPARATOR() public view returns (bytes32) {\n    return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : _computeDomainSeparator();\n  }\n\n  /// @notice Computes the domain separator for this contract.\n  function _computeDomainSeparator() internal view returns (bytes32) {\n    return keccak256(\n      abi.encode(\n        keccak256(\n          \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        ),\n        keccak256(\"ERC6538Registry\"),\n        keccak256(\"1.0\"),\n        block.chainid,\n        address(this)\n      )\n    );\n  }\n}\n\n/// @notice Interface of the ERC1271 standard signature validation method for contracts as defined\n/// in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\ninterface IERC1271 {\n  /// @notice Should return whether the signature provided is valid for the provided data\n  /// @param hash Hash of the data to be signed\n  /// @param signature Signature byte array associated with _data\n  function isValidSignature(bytes32 hash, bytes memory signature)\n    external\n    view\n    returns (bytes4 magicValue);\n}\n"
    },
    "contracts/interfaces/IERC5564Announcer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\n/// NOTE very slight adaptation to code found here https://eips.ethereum.org/EIPS/eip-5564\n\n/// @notice Interface for announcing when something is sent to a stealth address.\ninterface IERC5564Announcer {\n  /// @dev Emitted when sending something to a stealth address.\n  /// @dev See the `announce` method for documentation on the parameters.\n  event Announcement (\n    uint256 indexed schemeId, \n    address indexed stealthAddress, \n    address indexed caller, \n    bytes ephemeralPubKey, \n    bytes metadata\n  );\n\n  /// @dev Called by integrators to emit an `Announcement` event.\n  /// @param schemeId The integer specifying the applied stealth address scheme.\n  /// @param stealthAddress The computed stealth address for the recipient.\n  /// @param ephemeralPubKey Ephemeral public key used by the sender.\n  /// @param metadata An arbitrary field MUST include the view tag in the first byte.\n  /// Besides the view tag, the metadata can be used by the senders however they like, \n  /// but the below guidelines are recommended:\n  /// The first byte of the metadata MUST be the view tag.\n  /// - When sending/interacting with the native token of the blockchain (cf. ETH), the metadata SHOULD be structured as follows:\n  ///     - Byte 1 MUST be the view tag, as specified above.\n  ///     - Bytes 2-5 are `0xeeeeeeee`\n  ///     - Bytes 6-25 are the address 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE.\n  ///     - Bytes 26-57 are the amount of ETH being sent.\n  /// - When interacting with ERC-20/ERC-721/etc. tokens, the metadata SHOULD be structured as follows:\n  ///   - Byte 1 MUST be the view tag, as specified above.\n  ///   - Bytes 2-5 are a function identifier. When a function selector (e.g.\n  ///     the first (left, high-order in big-endian) four bytes of the Keccak-256\n  ///     hash of the signature of the function, like Solidity and Vyper use) is\n  ///     available, it MUST be used.\n  ///   - Bytes 6-25 are the token contract address.\n  ///   - Bytes 26-57 are the amount of tokens being sent/interacted with for fungible tokens, or\n  ///     the token ID for non-fungible tokens.\n  function announce (\n    uint256 schemeId, \n    address stealthAddress, \n    bytes memory ephemeralPubKey, \n    bytes memory metadata\n  ) external;\n}"
    },
    "contracts/interfaces/IERC6538Registry.sol": {
      "content": "// SPDX-License-Identifier: CC0-1.0\npragma solidity 0.8.23;\n\n/// @dev Interface for calling the `ERC6538Registry` contract to map accounts to their stealth\n/// meta-address. See [ERC-6538](https://eips.ethereum.org/EIPS/eip-6538) to learn more.\ninterface IERC6538Registry {\n  /// @notice Emitted when an invalid signature is provided to `registerKeysOnBehalf`.\n  error ERC6538Registry__InvalidSignature();\n\n  /// @dev Emitted when a registrant updates their stealth meta-address.\n  /// @param registrant The account that registered the stealth meta-address.\n  /// @param schemeId Identifier corresponding to the applied stealth address scheme, e.g. 1 for\n  /// secp256k1, as specified in ERC-5564.\n  /// @param stealthMetaAddress The stealth meta-address.\n  /// [ERC-5564](https://eips.ethereum.org/EIPS/eip-5564) bases the format for stealth\n  /// meta-addresses on [ERC-3770](https://eips.ethereum.org/EIPS/eip-3770) and specifies them as:\n  ///   st:<shortName>:0x<spendingPubKey>:<viewingPubKey>\n  /// The chain (`shortName`) is implicit based on the chain the `ERC6538Registry` is deployed on,\n  /// therefore this `stealthMetaAddress` is just the `spendingPubKey` and `viewingPubKey`\n  /// concatenated.\n  event StealthMetaAddressSet(\n    address indexed registrant, uint256 indexed schemeId, bytes stealthMetaAddress\n  );\n\n  /// @notice Emitted when a registrant increments their nonce.\n  /// @param registrant The account that incremented the nonce.\n  /// @param newNonce The new nonce value.\n  event NonceIncremented(address indexed registrant, uint256 newNonce);\n\n  /// @notice Sets the caller's stealth meta-address for the given scheme ID.\n  /// @param schemeId Identifier corresponding to the applied stealth address scheme, e.g. 1 for\n  /// secp256k1, as specified in ERC-5564.\n  /// @param stealthMetaAddress The stealth meta-address to register.\n  function registerKeys(uint256 schemeId, bytes calldata stealthMetaAddress) external;\n\n  /// @notice Sets the `registrant`'s stealth meta-address for the given scheme ID.\n  /// @param registrant Address of the registrant.\n  /// @param schemeId Identifier corresponding to the applied stealth address scheme, e.g. 1 for\n  /// secp256k1, as specified in ERC-5564.\n  /// @param signature A signature from the `registrant` authorizing the registration.\n  /// @param stealthMetaAddress The stealth meta-address to register.\n  /// @dev Supports both EOA signatures and EIP-1271 signatures.\n  /// @dev Reverts if the signature is invalid.\n  function registerKeysOnBehalf(\n    address registrant,\n    uint256 schemeId,\n    bytes memory signature,\n    bytes calldata stealthMetaAddress\n  ) external;\n\n  /// @notice Increments the nonce of the sender to invalidate existing signatures.\n  function incrementNonce() external;\n\n  /// @notice Returns the domain separator used in this contract.\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n  /// @notice Returns the stealth meta-address for the given `registrant` and `schemeId`.\n  function stealthMetaAddressOf(address registrant, uint256 schemeId)\n    external\n    view\n    returns (bytes memory);\n\n  /// @notice Returns the EIP-712 type hash used in `registerKeysOnBehalf`.\n  function ERC6538REGISTRY_ENTRY_TYPE_HASH() external view returns (bytes32);\n\n  /// @notice Returns the nonce of the given `registrant`.\n  function nonceOf(address registrant) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\ninterface IToken {\n    function transferFrom(address, address, uint256) external;\n\n    function balanceOf(address) external returns (uint256);\n\n    function approve(address, uint256) external;\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}