{
  "language": "Solidity",
  "sources": {
    "contracts/interfaces/IERC5564Announcer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\n/// NOTE very slight adaptation to code found here https://eips.ethereum.org/EIPS/eip-5564\n\n/// @notice Interface for announcing when something is sent to a stealth address.\ninterface IERC5564Announcer {\n  /// @dev Emitted when sending something to a stealth address.\n  /// @dev See the `announce` method for documentation on the parameters.\n  event Announcement (\n    uint256 indexed schemeId, \n    address indexed stealthAddress, \n    address indexed caller, \n    bytes ephemeralPubKey, \n    bytes metadata\n  );\n\n  /// @dev Called by integrators to emit an `Announcement` event.\n  /// @param schemeId The integer specifying the applied stealth address scheme.\n  /// @param stealthAddress The computed stealth address for the recipient.\n  /// @param ephemeralPubKey Ephemeral public key used by the sender.\n  /// @param metadata An arbitrary field MUST include the view tag in the first byte.\n  /// Besides the view tag, the metadata can be used by the senders however they like, \n  /// but the below guidelines are recommended:\n  /// The first byte of the metadata MUST be the view tag.\n  /// - When sending/interacting with the native token of the blockchain (cf. ETH), the metadata SHOULD be structured as follows:\n  ///     - Byte 1 MUST be the view tag, as specified above.\n  ///     - Bytes 2-5 are `0xeeeeeeee`\n  ///     - Bytes 6-25 are the address 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE.\n  ///     - Bytes 26-57 are the amount of ETH being sent.\n  /// - When interacting with ERC-20/ERC-721/etc. tokens, the metadata SHOULD be structured as follows:\n  ///   - Byte 1 MUST be the view tag, as specified above.\n  ///   - Bytes 2-5 are a function identifier. When a function selector (e.g.\n  ///     the first (left, high-order in big-endian) four bytes of the Keccak-256\n  ///     hash of the signature of the function, like Solidity and Vyper use) is\n  ///     available, it MUST be used.\n  ///   - Bytes 6-25 are the token contract address.\n  ///   - Bytes 26-57 are the amount of tokens being sent/interacted with for fungible tokens, or\n  ///     the token ID for non-fungible tokens.\n  function announce (\n    uint256 schemeId, \n    address stealthAddress, \n    bytes memory ephemeralPubKey, \n    bytes memory metadata\n  ) external;\n}"
    },
    "contracts/interfaces/IStealthereum.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.22;\n\ninterface IStealthereum {\n\n    error WrongMsgValue();\n    error MalformattedMetadata();\n    error NativeTransferFailed();\n    error ArrayLengthMismatch();\n\n    /// @notice The StealthTransfer struct\n    /// @param schemeId id for the stealth address cryptographic scheme (1 = secp256k1 with view tags)\n    /// @param stealthAddress the stealth address to transfer to\n    /// @param ephemeralPubkey the ephemeral pubkey used to create the stealth address (and used by recipient to find the private key)\n    /// @param viewTag the view tag for quicker scanning\n    /// @param tokens list of tokens to transfer to the stealth address (supports both ERC20 and ERC721)\n    /// @param values the amount (or tokenId, in the case of ERC721) to transfer per token address\n    /// @param extraMetadata any extra data to append to the metadata\n    struct StealthTransfer {\n        uint256 schemeId; \n        address stealthAddress;\n        bytes ephemeralPubkey;\n        uint8 viewTag;\n        address[] tokens;\n        uint256[] values;\n        bytes extraMetadata;\n    }\n\n    /// @notice stealth transfer native token and/or any number of ERC20 / ERC721 tokens directly to a stealth address on announcement to chain's ERC5564Announcer\n    /// @param transferData a struct containing stealth transfer params, see StealthTransfer struct\n    /// @dev Caller must approve `values[i]` for each `tokens[i]` contract before invoking this function.\n    /// This function will properly encode metadata on your behalf complying with ERC5564 spec and extending it.\n    /// Any non-zero msg.value will be transferred to the stealth address too.\n    function stealthTransfer(\n        StealthTransfer calldata transferData\n    ) external payable;\n\n    /// @notice stealth transfers to multiple stealth addresses in one batched call\n    /// @param transfersData list of structs containing containing stealth transfer params, see StealthTransfer struct\n    /// @param msgvalues native transfer amounts per StealthTransfer\n    /// @dev Caller must approve `values[i]` for each `tokens[i]` contract (in each StealthTransfer) before invoking this function.\n    /// This function will properly encode metadata on your behalf compying with ERC5564 suggestions.\n    function batchStealthTransfers(\n        StealthTransfer[] calldata transfersData,\n        uint256[] calldata msgvalues\n    ) external payable;\n\n    /// @notice parse metadata to check for valid formatting and what transfers it encodes\n    /// @param metadata the bytes of metadata to parse\n    /// @return valueETH amount of native ETH transferred\n    /// @return tokens list of token transfers\n    /// @return values values transferred in token transfers\n    /// @return extraDataLen length of custom extra data appended to the standard metadata format\n    /// @dev METADATA SPEC: the first (n)(56)+1 bytes of metadata MUST conform to the following format (where `n` is number of native or token transfers).\n    /// First byte MUST be a view tag (if no view tag, can be any arbitrary byte but should be 0x00).\n    /// IF forwarding the native token (e.g. ETH) next 56 bytes MUST be 24 bytes of 0xee + 32 byte uint matching msg.value.\n    /// Next 56 byte chunks MAY start with 0x23b872dd (transferFrom) to be considered a token transfer.\n    /// These token transfer 56 byte chunks go 0x23b872dd + 20 byte token address + 32 byte uint of amount/tokenId to transfer.\n    /// Once the start of a 56 byte chunk does not start with 0x23b872dd, we consider this unstructured appended data.\n    function parseMetadata(\n        bytes memory metadata\n    ) external pure returns (uint256 valueETH, address[] memory tokens, uint256[] memory values, uint256 extraDataLen);\n\n    /// @notice encode metadata from the list of transfers and any \"extra\" appended metadata\n    /// @param msgvalue amount of native eth transferred\n    /// @param viewTag view tag for the stealth transfer\n    /// @param tokens list of token addresses (ERC20 or ERC721)\n    /// @param values list of values transferred per token\n    /// @param extraMetadata any extra data that sender wants to append to the metadata\n    /// @return metadata the encoded metadata output\n    function getMetadata(\n        uint256 msgvalue,\n        uint8 viewTag,\n        address[] calldata tokens,\n        uint256[] calldata values,\n        bytes memory extraMetadata\n    ) external pure returns (bytes memory metadata);\n}"
    },
    "contracts/interfaces/IStealthSwapHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.22;\n\nimport {IStealthereum} from \"./IStealthereum.sol\";\n\ninterface IStealthSwapHelper {\n    /// @notice The StealthSwap struct\n    /// @param schemeId id for the stealth address cryptographic scheme (1 = secp256k1 with view tags)\n    /// @param stealthAddress the stealth address to transfer to\n    /// @param ephemeralPubkey the ephemeral pubkey used to create the stealth address (and used by recipient to find the private key)\n    /// @param viewTag the view tag for quicker scanning\n    /// @param extraMetadata any extra data to append to the metadata\n    /// @param inputToken input token address, for swap (use 0xeeee....) for native ETH\n    /// @param inputAmount amount of inputToken to swap\n    /// @param outputToken address of output token for swap\n    /// @param swapRouter target contract to call for swap action\n    /// @param swapPayload to call on target contract for swap action\n    /// @param nativeTransfer amount of native ETH to transfer to the stealth address receiving the output of the swap\n    struct StealthSwap {\n        uint256 schemeId;\n        address stealthAddress;\n        bytes ephemeralPubkey;\n        uint8 viewTag;\n        bytes extraMetadata;\n        address inputToken;\n        uint256 inputAmount;\n        address outputToken;\n        address swapRouter;\n        bytes swapPayload;\n        uint256 nativeTransfer;\n    }\n\n    /// @notice swap ETH or an ERC20 into an ERC20 before sending it to a stealth address\n    /// @param swap a struct containing swap info and stealth transfer info, see StealthSwap struct.\n    function stealthSwap(\n        StealthSwap calldata swap\n    ) external payable;\n\n    /// @notice batch a stealth swap operation with a second stealth transfer\n    /// @param swap a struct containing swap info and stealth transfer info, see StealthSwap struct.\n    /// @param transferData a struct containing stealth transfer params, see StealthTransfer struct.\n    /// @param transferValueETH amount of native token to send in the second stealth transfer.\n    /// @dev Meant for doing a stealth swap and then clearing the rest of the used stealth address to a new \"change address\" all in one batched op\n    function stealthSwapAndBatch(\n        StealthSwap calldata swap,\n        IStealthereum.StealthTransfer calldata transferData,\n        uint256 transferValueETH\n    ) external payable;\n    \n}"
    },
    "contracts/interfaces/IToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\ninterface IToken {\n    function transferFrom(address, address, uint256) external;\n\n    function balanceOf(address) external returns (uint256);\n\n    function approve(address, uint256) external;\n}"
    },
    "contracts/Stealthereum.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.22;\n\nimport {IERC5564Announcer} from \"./interfaces/IERC5564Announcer.sol\";\nimport {IToken} from \"./interfaces/IToken.sol\";\nimport {IStealthereum} from \"./interfaces/IStealthereum.sol\";\n\n/// @title stealth.ereum\n/// @author mrs kzg.eth\n/// @notice ERC5564 compliant stealth addresses integration with an extended metadata standard\ncontract Stealthereum is IStealthereum {\n\n    bytes32 internal constant _ETH_AND_SELECTOR = 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee0000000000000000;\n    bytes32 internal constant _TRANSFER_FROM_SELECTOR = 0x23b872dd00000000000000000000000000000000000000000000000000000000;\n\n    /// @dev chain's canonical ERC5564 announcer singleton contract\n    IERC5564Announcer public immutable announcer;\n\n    constructor(address _announcer) {\n        announcer = IERC5564Announcer(_announcer);\n    }\n\n    /// @inheritdoc IStealthereum\n    function stealthTransfer(\n        StealthTransfer calldata transferData\n    ) external payable {\n        bytes memory metadata = getMetadata(\n            msg.value,\n            transferData.viewTag,\n            transferData.tokens,\n            transferData.values,\n            transferData.extraMetadata\n        );\n\n        _doTransfers(\n            msg.value,\n            msg.sender,\n            transferData.stealthAddress,\n            transferData.tokens,\n            transferData.values\n        );\n\n        announcer.announce(\n            transferData.schemeId,\n            transferData.stealthAddress, \n            transferData.ephemeralPubkey, \n            metadata\n        );\n    }\n\n    /// @inheritdoc IStealthereum\n    function batchStealthTransfers(\n        StealthTransfer[] calldata transfersData,\n        uint256[] calldata msgvalues\n    ) external payable {\n        uint256 len = transfersData.length;\n        if (msgvalues.length != len) revert ArrayLengthMismatch();\n        uint256 startValue = msg.value;\n        uint256 endValue;\n        for (uint256 i; i < len; i++) {\n            bytes memory metadata = getMetadata(\n                msgvalues[i],\n                transfersData[i].viewTag,\n                transfersData[i].tokens,\n                transfersData[i].values,\n                transfersData[i].extraMetadata\n            );\n\n            _doTransfers(\n                msgvalues[i],\n                msg.sender,\n                transfersData[i].stealthAddress,\n                transfersData[i].tokens,\n                transfersData[i].values\n            );\n\n            announcer.announce(\n                transfersData[i].schemeId,\n                transfersData[i].stealthAddress, \n                transfersData[i].ephemeralPubkey, \n                metadata\n            );\n\n            endValue += msgvalues[i];\n        }\n\n        if (endValue != startValue) revert WrongMsgValue();\n    }\n\n    /// @inheritdoc IStealthereum\n    function parseMetadata(\n        bytes memory metadata\n    ) external pure returns (uint256 valueETH, address[] memory tokens, uint256[] memory values, uint256 extraDataLen) {\n        uint256 len = metadata.length;\n        if (len < 57) revert MalformattedMetadata();\n        \n        bytes32 checkSelector;\n        assembly {\n            checkSelector := shl(0x40, shr(0x40, mload(add(metadata, 0x21))))\n        }\n\n        bool sendsETH = checkSelector == _ETH_AND_SELECTOR;\n        if (sendsETH) {\n            assembly {\n                valueETH := mload(add(metadata, 0x39))\n            }\n        }\n\n        uint256 n = (len - 1)/56;\n        uint256 arrayLen;\n        if (n > 1 || !sendsETH) {\n            assembly {\n                let startPtr := add(metadata, 0x59)\n                let max := sub(n, 0x01)\n                if iszero(sendsETH) {\n                    max := n\n                    startPtr := add(metadata, 0x21)\n                }\n                for {let i := 0x00} lt(i, max) {i := add(i, 0x01)} {\n                    switch eq(shl(0xe0, shr(0xe0, mload(add(startPtr, mul(i, 0x38))))), _TRANSFER_FROM_SELECTOR)\n                    case 0 {\n                        break\n                    }\n                    default {\n                        arrayLen := add(arrayLen, 0x01)\n                    }\n                }\n                let tFree := mload(0x40)\n                let tDataPtr := add(tFree, 0x20)\n                let vFree := add(tDataPtr, mul(arrayLen, 0x20))\n                let vDataPtr := add(vFree, 0x20)\n                let tStartPtr := add(startPtr, 0x04)\n                let vStartPtr := add(startPtr, 0x18)\n                mstore(tFree, arrayLen)\n                mstore(vFree, arrayLen)\n                for {let j := 0x00} lt(j, arrayLen) {j := add(j, 0x01)} {\n                    mstore(add(tDataPtr, mul(j, 0x20)), shr(0x60, mload(add(tStartPtr, mul(j, 0x38)))))\n                    mstore(add(vDataPtr, mul(j, 0x20)), mload(add(vStartPtr, mul(j, 0x38))))\n                }\n\n                tokens := tFree\n                values := vFree\n\n                mstore(0x40, add(tFree, add(mul(arrayLen, 0x40), 0x40))) // update free memory pointer\n            }\n        }\n\n        uint256 start = sendsETH ? 57+arrayLen*56 : 1+arrayLen*56;\n        extraDataLen = metadata.length - start;\n    }\n\n    /// @inheritdoc IStealthereum\n    function getMetadata(\n        uint256 msgvalue,\n        uint8 viewTag,\n        address[] calldata tokens,\n        uint256[] calldata values,\n        bytes memory extraMetadata\n    ) public pure returns (bytes memory metadata) {\n        uint256 len = tokens.length;\n        if (len != values.length) revert ArrayLengthMismatch();\n\n        bool sendsETH = msgvalue > 0;\n        uint256 metadataLen = sendsETH ? 56*(len+1)+1 : 56*len+1;\n        bytes memory data = new bytes(metadataLen);\n\n        assembly {\n            let startPtr := add(data, 0x21)\n            let n := div(sub(metadataLen, 0x01), 0x38)\n            mstore8(add(data, 0x20), viewTag)\n            if gt(sendsETH, 0) {\n                mstore(add(data, 0x21), _ETH_AND_SELECTOR)\n                mstore(add(data, 0x39), msgvalue)\n\n                startPtr := add(data, 0x59)\n                n := sub(n, 0x01)\n            }\n            for {let i := 0x00} lt(i, n) {i := add(i, 0x01)} {\n                let k := add(startPtr, mul(i, 0x38))\n                mstore(k, _TRANSFER_FROM_SELECTOR)\n                calldatacopy(0x00, add(tokens.offset, mul(i, 0x20)), 0x20)\n                calldatacopy(0x20, add(values.offset, mul(i, 0x20)), 0x20)\n                mstore(add(k, 0x04), shl(0x60, mload(0x00)))\n                mstore(add(k, 0x18), mload(0x20))\n            }\n        }\n\n        metadata = bytes.concat(data, extraMetadata);\n    }\n\n    function _doTransfers(\n        uint256 msgvalue,\n        address msgsender,\n        address stealthAddress,\n        address[] memory tokens,\n        uint256[] memory values\n    ) internal {\n        for (uint256 i = 0; i < tokens.length; i++) {\n            IToken(tokens[i]).transferFrom(msgsender, stealthAddress, values[i]);\n        }\n\n        if (msgvalue > 0) {\n            bool success;\n            assembly {\n                success := call(gas(), stealthAddress, msgvalue, 0, 0, 0, 0)\n            }\n            if (!success) revert NativeTransferFailed();\n        }\n    }\n\n    receive() external payable {}\n}"
    },
    "contracts/StealthSwapHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.22;\n\nimport {IToken} from \"./interfaces/IToken.sol\";\nimport {\n    IStealthSwapHelper,\n    IStealthereum\n} from \"./interfaces/IStealthSwapHelper.sol\";\n\n/// @title Stealth Swap Helper\n/// @author mrs kzg.eth\n/// @notice router contract for performing an ERC20 token swap before sending the result of the swap to a stealth address\ncontract StealthSwapHelper is IStealthSwapHelper {\n\n    error ArrayLengthMismatch();\n    error NoSwapOutput();\n    error WrongMsgValue();\n    error SwapCallFailed();\n\n    address internal ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    IStealthereum public immutable stealthereum;\n\n    constructor(address _stealthereum) {\n        stealthereum = IStealthereum(_stealthereum);\n    }\n\n    /// @inheritdoc IStealthSwapHelper\n    function stealthSwap(\n        StealthSwap calldata swap\n    ) external payable {\n        uint256 value;\n        if (swap.inputToken == ETH) {\n            if (swap.inputAmount + swap.nativeTransfer != msg.value) revert WrongMsgValue();\n            value = swap.inputAmount;\n        } else {\n            IToken(swap.inputToken).transferFrom(msg.sender, address(this), swap.inputAmount);\n            IToken(swap.inputToken).approve(swap.swapRouter, swap.inputAmount);\n        }\n        \n        (bool success,) = swap.swapRouter.call{value: value}(swap.swapPayload);\n        if (!success) revert SwapCallFailed();\n\n        uint256 outputAmount = IToken(swap.outputToken).balanceOf(address(this));\n        if (outputAmount == 0) revert NoSwapOutput();\n\n        address[] memory tokens = new address[](1);\n        tokens[0] = swap.outputToken;\n        uint256[] memory values = new uint256[](1);\n        values[0] = outputAmount;\n\n        IToken(swap.outputToken).approve(address(stealthereum), outputAmount);\n\n        stealthereum.stealthTransfer{value: swap.nativeTransfer}(\n            IStealthereum.StealthTransfer({\n                schemeId: swap.schemeId,\n                stealthAddress: swap.stealthAddress,\n                ephemeralPubkey: swap.ephemeralPubkey,\n                viewTag: swap.viewTag,\n                tokens: tokens,\n                values: values,\n                extraMetadata: swap.extraMetadata\n            })\n        );\n    }\n\n    /// @inheritdoc IStealthSwapHelper\n    function stealthSwapAndBatch(\n        StealthSwap calldata swap,\n        IStealthereum.StealthTransfer calldata transferData,\n        uint256 transferValueETH\n    ) external payable {\n        uint256 swapValue;\n        if (swap.inputToken == ETH) {\n            if (swap.inputAmount + swap.nativeTransfer + transferValueETH != msg.value) revert WrongMsgValue();\n            swapValue = swap.inputAmount;\n        } else {\n            IToken(swap.inputToken).transferFrom(msg.sender, address(this), swap.inputAmount);\n            IToken(swap.inputToken).approve(swap.swapRouter, swap.inputAmount);\n        }\n        \n        (bool success,) = swap.swapRouter.call{value: swapValue}(swap.swapPayload);\n        if (!success) revert SwapCallFailed();\n\n        uint256 outputAmount = IToken(swap.outputToken).balanceOf(address(this));\n        if (outputAmount == 0) revert NoSwapOutput();\n\n        for (uint256 i = 0; i < transferData.tokens.length; i++) {\n            address token = transferData.tokens[i];\n            uint256 v = transferData.values[i];\n            IToken(token).transferFrom(msg.sender, address(this), v);\n            IToken(token).approve(address(stealthereum), v);\n        }\n\n        address[] memory tokens = new address[](1);\n        tokens[0] = swap.outputToken;\n        uint256[] memory values = new uint256[](1);\n        values[0] = outputAmount;\n\n        IStealthereum.StealthTransfer[] memory transfersData = new IStealthereum.StealthTransfer[](2);\n        transfersData[0] = IStealthereum.StealthTransfer({\n            schemeId: swap.schemeId,\n            stealthAddress: swap.stealthAddress,\n            ephemeralPubkey: swap.ephemeralPubkey,\n            viewTag: swap.viewTag,\n            tokens: tokens,\n            values: values,\n            extraMetadata: swap.extraMetadata\n        });\n        transfersData[1] = transferData;\n\n        uint256[] memory msgvalues = new uint256[](2);\n        msgvalues[0] = swap.nativeTransfer;\n        msgvalues[1] = transferValueETH;\n\n        IToken(swap.outputToken).approve(address(stealthereum), outputAmount);\n\n        stealthereum.batchStealthTransfers{value: swap.nativeTransfer+transferValueETH}(\n            transfersData,\n            msgvalues\n        );\n    }\n\n    receive() external payable {}\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}